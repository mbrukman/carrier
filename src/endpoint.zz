using <stdio.h>::{printf};
using <string.h>::{memset, memcpy};
using string;
using net::address;
using err;
using byteorder;
using net::udp;
using time;
using bootstrap;
using identity;
using initiator;
using io::unix;
using io;
using net;
using cipher;
using hex;
using channel;
using router;
using peering;
using log;
using pool;
using slice;
using hpack;
using stream;
using protonerf;
using proto;
using noise;
using responder;
using peering;

export const char* PROLOGUE = "carrier has arrived";
export const char* SIGN_PURPOSE = "carrier handshake hash 1";

enum State {
    Connecting,
    Connected,
    Closed,
}

struct ConnectingState {
    bootstrap::Broker       mut current_broker;
    initiator::Initiator    mut initiator;
    usize trying_broker_index;
    usize retry_sending;
}

union StateM {
    ConnectingState         connecting;
    router::Router          connected;
}

export struct Endpoint+ {
    net::Engine*            netengine;
    bootstrap::Store mut*   store;

    initiator::Move         cluster_move;
    identity::Identity      cluster_target;

    stream::Config *        broker_stream_registry[2];
    stream::Config *        p2p_stream_registry[16];

    udp::Socket     mut udp4;
    udp::Socket     mut udp6;
    io::Io          mut timeout;

    State           mut state;
    StateM          mut statem;

    pool::Pool+     mut framebuffer;
}

export fn new(Endpoint+xt mut* self, err::Err+et mut*e, net::Engine *netengine, bootstrap::Store mut* store, io::Async mut* async)
    where err::checked(*e)
    where xt > xt/32
    model safe(self->store)
{
    memset(self, 0, sizeof(Endpoint));
    self->framebuffer.new(32);

    self->netengine = netengine;
    self->store     = store;

    log::info("truststore is empty. bootstrap via dns");
    self->state = State::Connecting;
    self->do_state_connect(e, async);
}

export fn broker(Endpoint mut* self) -> channel::Channel mut *
    model safe(return)
{
    return &self->statem.connected.channels[0];
}

export fn cluster_target(Endpoint+xt mut* self, identity::Identity * target)
{
    memcpy(&self->cluster_target, target, sizeof(identity::Identity));
    self->cluster_move = initiator::Move::Target;
}

export fn close(Endpoint mut* self)
{
    switch self->state {
        State::Connecting => {
            self->udp4.close();
            self->udp6.close();
        }
        State::Connected => {
            self->statem.connected.close();
        }
    }
    self->state = State::Closed;
}

export fn register_stream(Endpoint mut* self, stream::Config *conf)
{
    for (usize mut i = 0; i < static(len(self->p2p_stream_registry)); i++) {
        if self->p2p_stream_registry[i] == 0 {
            self->p2p_stream_registry[i] = conf;
            return;
        }
    }
}



fn next_broker(Endpoint mut* self) -> bool
{
    static_attest(safe(self->store));
    for (usize mut i = 0; i < bootstrap::MAX_BROKERS; i++) {
        if self->statem.connecting.trying_broker_index >= bootstrap::MAX_BROKERS {
            self->statem.connecting.trying_broker_index = 0;
        }
        static_attest(self->statem.connecting.trying_broker_index < len(self->store->broker));
        if self->store->broker[self->statem.connecting.trying_broker_index].protocol != 0 {
            log::debug("loading broker slot %zu", self->statem.connecting.trying_broker_index);
            memcpy(&self->statem.connecting.current_broker,
                &self->store->broker[self->statem.connecting.trying_broker_index],
                sizeof(bootstrap::Broker));
            self->statem.connecting.trying_broker_index += 1;
            return true;
        }
        self->statem.connecting.trying_broker_index += 1;
    }
    return false;
}

static u16 PORTS[] = {53, 443, 8443, 80, 123};




fn do_state_connect(Endpoint+xt mut* self, err::Err+et mut*e, io::Async mut* async)
    where err::checked(*e)
{
    static_attest(safe(self->store));
    log::info("trustvector complete, ring has %zu brokers", self->store->broker_count());

    self->state = State::Connecting;
    memset(&self->statem.connecting, 0, sizeof(ConnectingState));

    static_attest(safe(self->netengine));
    new addr4 = address::from_cstr("0.0.0.0:1212");
    self->udp4 = self->netengine->new_udp(e, &addr4, async);
    if err::check(e) {
        return;
    }

    new addr6 = address::from_cstr("[::1]:0");
    self->udp6 = self->netengine->new_udp(e, &addr6, async);
    if err::check(e) {
        return;
    }

    if !self->next_broker(){
        err::fail(e, 2, "no brokers in bootstrap store");
        return;
    }
}

export fn poll(Endpoint mut* self, err::Err+et mut*e, io::Async mut* async) -> io::Result
    where err::checked(*e)
{
    static_attest(safe(self->store));

    switch self->state {
        // TODO retry timeout
        State::Connecting => {

            // make sure we always activate
            if io::valid(&self->timeout) {
                async->select(e, &self->timeout, io::Ready::Read);
                if err::check(e) {return io::Result::Error; }
            }
            if io::valid(&self->udp4) {
                async->select(e, &self->udp4, io::Ready::Read);
                if err::check(e) {return io::Result::Error; }
            }
            if io::valid(&self->udp6) {
                async->select(e, &self->udp6, io::Ready::Read);
                if err::check(e) {return io::Result::Error; }
            }

            // receive
            address::Address    mut fromaddr = {0};
            self->statem.connecting.initiator.pkt.clear();
            if self->udp4.recvfrom(e, &self->statem.connecting.initiator.pkt, &fromaddr) == io::Result::Ready {
                err::new(e);

                string::String+100 mut bufx = {0};
                fromaddr.to_string(&bufx);

                channel::Channel  mut broker_chan = {0};
                bootstrap::Broker mut redir = {0};
                self->statem.connecting.initiator.complete(e, &broker_chan, &redir);
                if err::check(e) {
                    e->eprint();
                    err::new(e);
                    // don't return here. we might have stuff to set the timer in the rest of the code
                } else if redir.protocol != 0 {
                    memcpy(&self->statem.connecting.current_broker, &redir, sizeof(bootstrap::Broker));
                    self->statem.connecting.retry_sending = 0;
                    self->timeout.close();
                    return self->poll(e, async);
                } else {
                    self->state = State::Connected;
                    memset(&self->statem , 0, sizeof(StateM));

                    broker_chan.peering.received(peering::Transport::Udp, fromaddr, peering::Class::Internet);
                    broker_chan.q.allocator = &self->framebuffer;
                    broker_chan.store  = self->store;
                    broker_chan.this_is_the_broker_channel = true;

                    self->statem.connected  = router::new(broker_chan, self->udp4, self->udp6);
                    self->statem.connected.channels[0].endpoint = self;

                    return io::Result::Ready;
                }
                err::new(e);
            }
            if err::check(e) {return io::Result::Error; }

            // or timeout

            if self->timeout.valid() {
                u8 mut buf[16];
                usize mut l = 16;
                io::Result rr = self->timeout.read_bytes(e, buf, &l);
                if err::check(e) {return io::Result::Error; }
                if rr != io::Result::Ready {
                    return rr;
                }
                log::warn("timeout waiting for broker response");
            }
            self->timeout.close();


            usize mut wait = 0;
            switch self->statem.connecting.retry_sending {
                0       => { wait = 100  }
                1       => { wait = 300  }
                2       => { wait = 600  }
                default => { wait = 2000 }
            }

            self->timeout = io::timeout(async, e, time::from_millis(wait));
            if err::check(e) {return io::Result::Error; }
            async->select(e, &self->timeout, io::Ready::Read);
            if err::check(e) {return io::Result::Error; }

            if self->statem.connecting.retry_sending > 5 {
                self->statem.connecting.retry_sending = 0;
                self->next_broker();
            }

            // TODO: abstract
            // TODO: this is stupid in the first place. the protocol needs a different replay protection
            time::Time now = time::real();
            self->store->time = now.to_millis();


            address::Address  mut ip4addr = {0};
            address::Address  mut ip6addr = {0};
            identity::Address mut xaddr   = {0};

            if !bootstrap::from_store(&self->statem.connecting.current_broker, &ip4addr, &ip6addr, &xaddr) {
                err::fail(e, 3, "current broker is empty");
                return io::Result::Error;
            }

            self->statem.connecting.initiator.initiate(
                e,
                true,
                (identity::Secret*)&(self->store->secret),
                self->cluster_move,
                &self->cluster_target,
                &xaddr,
                self->store->time
            );
            if err::check(e) {return io::Result::Error;}

            string::String+150 mut dbn = {0};
            ip4addr.ip_to_string(&dbn);
            dbn.append_cstr(" ");
            static_attest(len(&dbn.mem) > dbn.len);
            dbn.len += identity::address_to_str(e, dbn.mem + dbn.len, 150 - dbn.len, &xaddr);
            if err::check(e) {return io::Result::Error; }

            log::debug("attempt %zu sending %zu bytes to %.*s",
                self->statem.connecting.retry_sending,
                self->statem.connecting.initiator.pkt.len,
                (int)dbn.len, dbn.mem);

            ++self->statem.connecting.retry_sending;

            for (usize mut i= 0; i < static(len(PORTS));i++) {
                ip4addr.set_port(PORTS[i]);
                ip6addr.set_port(PORTS[i]);

                self->udp4.sendto(e, &self->statem.connecting.initiator.pkt, &ip4addr);
                err::new(e);

                if io::valid(&self->udp6) && ip6addr.valid() {
                    self->udp6.sendto(e, &self->statem.connecting.initiator.pkt, &ip6addr);
                    err::new(e);
                }
           }


            async->select(e, &self->udp4, io::Ready::Read);


            return io::Result::Later;
        }
        State::Connected => {
            return self->statem.connected.poll(e, async);
        }
        State::Closed => {
            log::debug("quitting time");
            return io::Result::Ready;
        }
    }

    return io::Result::Later;
}
