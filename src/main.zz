using <stdio.h>::{printf};
using <string.h>::{memcpy};
using <assert.h>::{assert};
using <stdlib.h>::{exit};
using err;
using channel;
using router;
using bootstrap;
using io::unix;
using net;
using io;
using time;
using endpoint;
using router;
using hex;
using log;
using pq;
using byteorder;
using identity;
using protonerf;
using string;
using stream;
using slice;
using net::address;
using hpack;
using slice::{Slice};
using publish;
using shell;
using sft;
using subscribe;
using connect;
using identity_kit;

export fn main(int argc, char ** argv) -> int
    where (usize)argc == len(argv)
{
    printf("SIZE Endpoint   %zu\n", sizeof(endpoint::Endpoint));
    printf("SIZE Channel    %zu\n", sizeof(channel::Channel));
    printf("SIZE Stream     %zu\n", sizeof(stream::Stream));



    if argc < 2 {
        printf("arg1: target identity");
        return 3;
    }
    char *argv1 = argv[1];

    err::Err+1000 mut e;
    err::new(&e);

    connect::Connect mut con = {0};
    static_attest(safe(argv1));
    static_attest(nullterm(argv1));
    identity::identity_from_str (&e, &con.target, argv1, string::strlen(argv1));
    e.abort();


    new ik = identity_kit::carriertoml(&e);
    e.abort();

    new store = bootstrap::empty();

    store.load_ik(&e, &ik);
    e.abort();

    unix::Async+20 mut async;
    async.new();

    bootstrap::sync(&e, &store, net::os(), &async, time::from_seconds(10));
    e.abort();

    //store.broker[0].protocol = 9;
    //char *xa = "oSaoKYLdcdqGAJPkt3scwP2H8FuEy58GjT59LwpigL4y7h9";
    //identity::address_from_str(&e, (identity::Address mut*)store.broker[0].xaddr, xa, static(len(xa)));
    //e.abort();
    //address::Address xi = address::from_cstr("127.0.0.1:8443");
    //memcpy(store.broker[0].ip4addr, xi.get_ip(), 4);


    identity::Identity mut id = {0};
    identity::identity_from_secret(&id, (identity::Secret*)&store.secret);
    char mut buf[64] = {0};
    identity::identity_to_str(&e, buf, 64, &id);
    e.abort();
    log::info("my identity: %s", buf);

    endpoint::Endpoint+1000 mut ep = {0};
    ep.new(&e, net::os(), &store, &async);
    e.abort();

    endpoint::cluster_target(&ep, &con.target);

    shell::register(&ep);
    sft::register(&ep);

    io::await(&async, &e, endpoint::poll, &ep, time::from_seconds(10));
    e.abort();
    log::debug("endpoint ready");

    //publish::start(&ep, &e);
    //e.abort();

    con.on_disconnect = on_disconnect;
    con.on_connect    = on_connect;
    con.start(&e, &ep);
    e.abort();

    io::await(&async, &e, endpoint::poll, &ep, time::infinite());
    ep.close();
    e.abort();

    log::debug("byeeee");


    return 0;
}


fn on_connect(channel::Channel mut*chan)
{
    err::Err+200 mut e;
    e.new();
    shell::open(&e, chan);
    e.abort();
}

fn on_disconnect(channel::Channel mut*chan)
{
    log::info("shell done");
    static_attest(safe(chan->endpoint));
    chan->endpoint->close();
}

